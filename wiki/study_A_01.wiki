#summary 01配置和代码编写
#labels Phase-Implementation

=第一段代码=
第一步新建java文件和xml配置文件，结构如下：
{{{
---
 |-Test.java
 |-Text.xml
}}}
xml配置文件和java文件在相同位置，文件名相同即可。<br>
这样就可通过如下代码获取工厂对象的实例。
{{{
FactoryManager.Instance instance = FactoryManager.createClassFactoryManager(this.getClass());
}}}
接下来就可以编写配置文件了，配置文件的结构如下：
{{{
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE eterna-config PUBLIC "eterna" "http://eterna.googlecode.com/files/eterna_1_5.dtd">
<!-- 上面这段配置指定了dtd文件，如果你的编辑器支持dtd文件的提示的话，那编写起来会方便很多 -->
<eterna-config>
   <factory>
      <objs>
         <!-- 在objs节点中定义需要的对象 -->
      </objs>
   </factory>
</eterna-config>
}}}
数据库中有个表 T_TABLE，数据如下：
||*id*||*strValue*||*intValue*||*dateValue*||
||1||test01||100||2012-01-01||
||2||test02||200||2012-02-02||

先针对这张表在配置中写一个简单的查询
{{{
<query name="get.t_table">
   <prepared-sql>
      select * from T_TABLE
      where id = ?
   </prepared-sql>
   <parameters>
      <parameter name="id" type="int"/>
   </parameters>
   <readers>
      <reader name="id" type="int"/>
      <reader name="strValue" type="String"/>
      <reader name="intValue" type="int"/>
      <reader name="dateValue" type="Date"/>
   </readers>
</query>
}}}
查询的配置定义好了，接着我们可以编写执行的代码
{{{
Connection conn = ...; // 这里的...为获取数据库链接的代码
EternaFactory factory = instance.getEternaFactory();
// get.t_table 为配置中定义的query的名称
QueryAdapter query = factory.createQueryAdapter("get.t_table");
// 设置查询的条件id
query.setInt("id", 1);
// 执行查询
ResultIterator ritr = query.executeQuery(conn);
if (ritr.hasMoreRow())
{
   ResultRow row = ritr.nextRow();
   System.out.println("strValue:" + row.getString("strValue"));
   System.out.println("intValue:" + row.getInt("intValue"));
   System.out.println("dateValue:" + row.getDate("dateValue"));
}
else
{
   System.out.println("未找到记录！");
}
--------------------------------------------
需要import的类如下
import self.micromagic.eterna.digester.FactoryManager;
import self.micromagic.eterna.share.EternaFactory;
import self.micromagic.eterna.sql.QueryAdapter;
import self.micromagic.eterna.sql.ResultIterator;
import self.micromagic.eterna.sql.ResultRow;
}}}
以上代码中`ResultIterator`和`ResultRow`在数据库链接关闭后仍然是可以使用的。<br>
关于获取数据库链接，如果你是按[http://code.google.com/p/eterna/wiki/initDB 数据库初始化]的说明进行的配置，可通过如下代码获得数据库链接
{{{
Connection conn = self.micromagic.util.Utility.getDataSource().getConnection();
}}}
如果这样的获取数据库链接的方法不能满足要求，还可根据[http://code.google.com/p/eterna/wiki/getDS 如何获得数据源]中的说明来获取数据库的链接。<br>
接下来我们在配置中写一个更新
{{{
<update name="modify.t_table">
   <prepared-sql>
      update T_TABLE set strValue = ?, intValue = ?, dateValue = ?
      where id = ?
   </prepared-sql>
   <parameters>
      <parameter name="strValue" type="String"/>
      <parameter name="intValue" type="int"/>
      <parameter name="myName" type="Date"/>
      <parameter name="id" type="int"/>
   </parameters>
</update>
}}}
通过上面的配置，我们可以看到参数的绑定是根据SQL语句中“`?`”出现的顺序一一绑定的，参数配置里name属性只是个别名，在设置参数的时候使用。<br>
执行这个更新的代码如下：
{{{
// modify.t_table 为配置中定义的update的名称
UpdateAdapter update = factory.createUpdateAdapter("modify.t_table");
// 设置需要修改的数据
update.setInt("id", 2);
update.setString("strValue", "modify02");  
update.setInt("intValue", 2000);  
// 因为配置中定义的这个参数名为myName
update.setDate("myName", new java.sql.Date(System.currentTimeMillis()));
// 执行更新
int modifiedCount = update.executeUpdate(conn);
System.out.println("更新记录数:" + modifiedCount); 
--------------------------------------------
还需要import的类如下
import self.micromagic.eterna.sql.UpdateAdapter;
}}}
<br>
=可以写得简单些吗=
当然能够进行裁剪，我们可以先对查询进行调整，可以把查询需要读取的内容单独定义出来，这样如果需要在多个地方使用就不用重复写了。
{{{
<reader-manager name="t_table.readers">
   <reader name="id" type="int"/>
   <reader name="strValue" type="String"/>
   <reader name="intValue" type="int"/>
   <reader name="dateValue" type="Date"/>
</reader-manager>
<query name="get.t_table">
   <prepared-sql>
      select * from T_TABLE
      where id = ?
   </prepared-sql>
   <parameters>
      <parameter name="id" type="int"/>
   </parameters>
   <readers baseReaderManager="t_table.readers"/>
</query>
}}}
这里定义了一个`reader-manager`“`t_table.readers`”，在`query`中通过`baseReaderManager`属性来指定使用已定义好的`reader-manager`。<br>
同样，也可以把更新中使用的参数列表单独定义出来
{{{
<parameter-group name="t_table.param">   
   <parameter name="strValue" type="String"/>
   <parameter name="intValue" type="int"/>
   <parameter name="dateValue" type="Date"/>
   <parameter name="id" type="int"/>
</parameter-group>
<update name="modify.t_table">
   <prepared-sql>
      update T_TABLE set strValue = ?, intValue = ?, dateValue = ?
      where id = ?
   </prepared-sql>
   <parameters>
      <parameter-ref groupName="t_table.param"/>
   </parameters>
</update>
}}}
这里定义了一个`parameter-group`“`t_table.param`”，在`update`中通过`parameter-ref`节点的属性`groupName`来指定使用已定义好的`parameter-group`。<br>
这样似乎没简化多少，`parameter-group`和`reader-manager`里的内容似乎有些重复，所以这两个内容可以合成一个，就像这样
{{{    
<update name="modify.t_table">
   <prepared-sql>
      update T_TABLE set strValue = ?, intValue = ?, dateValue = ?
      where id = ?
   </prepared-sql>
   <parameters>
      <parameter-ref groupName="reader:t_table.readers"/>
   </parameters>
</update>
}}}
通过`reader:`前缀表示将使用一个`reader-manager`来作为参数列表，不过这样似乎还有个问题，前面说过*参数的绑定是根据SQL语句中“`?`”出现的顺序一一绑定的*，这个`reader-manager`中的顺序是id, strValue, intValue, dateValue，和SQL语句的顺序不一致。这没关系，可以做如下修改
{{{    
<update name="modify.t_table">
   <prepared-sql>
      update T_TABLE set strValue = ?, intValue = ?, dateValue = ?
      where id = ?
   </prepared-sql>
   <parameters>
      <parameter-ref groupName="reader:t_table.readers" ignoreList="$ignoreSame"/>
      <parameter name="id" type="int"/>
   </parameters>
</update>
}}}
在`parameter-ref`节点中增加一个属性“ignoreList="$ignoreSame"”，表示忽略已出现的同名参数，在这里已经定义了`id`这个参数了，那么`t_table.readers`中出现在第一个的'id'参数就会被忽略，参数列表中的顺序就和SQL语句中的一致了。<br>
对于这个更新语句，如果列比较多的话，即要写参数列表，又要写SQL语句，这个量也不小。其实语句是可以部分生成的，看下面的修改
{{{    
<update name="modify.t_table">
   <prepared-sql>
      update T_TABLE set #auto[update,1,-2]
      where id = ?
   </prepared-sql>
   <parameters>
      <parameter-ref groupName="reader:t_table.readers" ignoreList="$ignoreSame"/>
      <parameter name="id" type="int"/>
   </parameters>
</update>
}}}
这段配置中，将列赋值的部分变成了一个表达式`#auto[update,1,-2]`，表示根据参数列表中的第一个参数至倒数第二个参数并根据`update`的格式来生成语句，其生成的语句就是“`strValue = ?, intValue = ?, dateValue = ?`”。<br>
这样简化后的配置就是如下效果
{{{
<reader-manager name="t_table.readers">
   <reader name="id" type="int"/>
   <reader name="strValue" type="String"/>
   <reader name="intValue" type="int"/>
   <reader name="dateValue" type="Date"/>
</reader-manager>

<query name="get.t_table">
   <prepared-sql>
      select * from T_TABLE
      where id = ?
   </prepared-sql>
   <parameters>
      <parameter name="id" type="int"/>
   </parameters>
   <readers baseReaderManager="t_table.readers"/>
</query>

<update name="modify.t_table">
   <prepared-sql>
      update T_TABLE set #auto[update,1,-2]
      where id = ?
   </prepared-sql>
   <parameters>
      <parameter-ref groupName="reader:t_table.readers" ignoreList="$ignoreSame"/>
      <parameter name="id" type="int"/>
   </parameters>
</update>
}}}
配置简化好了，如果参数比较多的话，一个个设置也是比较费工作的，所以代码中设置参数的部分也可以简化
{{{
// modify.t_table 为配置中定义的update的名称
UpdateAdapter update = factory.createUpdateAdapter("modify.t_table");
ParamSetManager psm = new ParamSetManager(update);
// request为javax.servlet.http.HttpServletRequest对象
// 此段代码会根据参数列表到request中寻找同名的参数自动进行设置      
psm.setParams(request.getParameterMap());   
// 执行更新
int modifiedCount = update.executeUpdate(conn);
System.out.println("更新记录数:" + modifiedCount);
--------------------------------------------
还需要import的类如下
import self.micromagic.eterna.model.ParamSetManager;
}}}
这里通过`ParamSetManager`进行参数的自动设置，这样就无需一行一行的写设置参数的代码了。
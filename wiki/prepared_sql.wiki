#summary 预备SQL语句的特殊语法
#labels Phase-Implementation

=概述=
框架中的预备SQL语句主要出现在query和update中的prepared-sql节点的内部文本中，和JDBC中的PreparedStatement一样，"?"表示需要设置参数。而"#"则是框架中添加的特殊标识，用于处理特殊的语法。<br>
第一个用处就是对单个字符的转义，如：<br>
##：表示一个"#"<br>
#?：表示这个"?"是一个字符，不会被认为是参数<br>
下面会分别介绍一些其他的用法。<br>
<br>
=sub 动态子语句=
动态子句就是一段SQL语句片段，它可以和主语句构成一个完整的SQL。<br>
完整的动态子句写法如下：
{{{
#sub[...$...]
或
#sub
}}}
以"#sub"开始，后面"[]"内的部分为子句的模板（如果没有模板则可去掉"[]"部分），"$"为动态子句出现的位置。如果模板部分需要出现"[]$"这些字符，可以用"#["，"#]"，"#$"代替。<br>
模板的作用是这样的，当插入的内容为空时，则动态子语句就变为空字符串，当插入的内容不为空时，则将插入的内容套入模板后再插入。<br>
例子如下：
{{{
预备SQL语句如下
SELECT * FROM TEST_TABLE
#sub[WHERE $]

当执行了
query.setSubSQL(1, "");
后，此段语句就变为
SELECT * FROM TEST_TABLE

当执行了
query.setSubSQL(1, "status = 0");
后，此段语句就变为
SELECT * FROM TEST_TABLE
WHERE status = 0
}}}
有了子句模板之后，代码中就不必关心这部分SQL片段插入后需要在之前或之后添加什么了。<br>
setSubSQL方法的说明：<br>
第一个参数为要设置的子句的索引值（即第几个子句），从1开始。<br>
第二个参数为要设置的子句片段。<br>
第三个参数为一个参数管理者，可以用于绑定子句中出现的参数。<br>
下面的例子为一个带参数的子句。
{{{
PreparerManager pm = new PreparerManager(2);
// 绑定第一个整型参数
ValuePreparer preparer = factory.getDefaultValuePreparerCreaterGenerator().createIntPreparer(1, 0);
// 绑定第二个字符串型参数
ValuePreparer preparer = factory.getDefaultValuePreparerCreaterGenerator().createStringPreparer(2, "用户名");
query.setSubSQL(1, "status = ? and userId = ?", pm);
}}}
<br>
=param 动态参数=
动态参数就是一段可以出现也可以不出现的，用于参数设置的语句片段。<br>
完整的动态参数写法如下：
{{{
#param(name)[...?...]
}}}
以"#param"开始，后面"(name)"内的"name"表示动态参数模板段分组的名称，同一名称的模板，要么在设置参数时同时出现，要么没有设置参数时都不出现。再后面"[]"内的部分为动态参数的模板部分，"?"为绑定的参数的位置。*一个动态参数的所有模板段中只能出现一个"?"*，如果模板部分需要出现"[]?"这些字符，可以用"#["，"#]"，"#?"代替。<br>
例子如下：
{{{
预备SQL语句如下
update TEST_TABLE set status = ? #param(id)[, userId = ?]

当执行了
set.setString(2, "用户名");
后，此段语句就变为
update TEST_TABLE set status = ? , userId = ?

当执行了
set.setIgnore(2);
后，此段语句就变为
update TEST_TABLE set status = ? 
}}}
关于模板段分组的名称的作用，看下下面这句插入语句
{{{
INSERT INTO TEST_TABLE (id #param(v)[, value] #param(s)[, status])
VALUES (? #param(v)[, ?] #param(s)[, ?])
}}}
这句语句中有两个动态参数，每个动态参数的模板分为了两段。<br>
<br>
=auto 动态语句生成=
动态语句生成是根据参数列表"parameters"来生成语句片段。<br>
完整的动态语句生成写法如下：
{{{
#auto[type,num1,num2]
}}}
以"#auto"开始，"type"为生成语句的模板，"num1"为重第几个参数开始动态生成语句片段，"num2"为生成到第几个参数。<br>
"num1"和"num2"为正数时表示从第一个开始，如1表示第一个、2表示第二个...<br>
"num1"和"num2"为负数时表示从最后一个开始，如-1表示最后一个、-2表示倒数第二个...<br>
"num1"和"num2"为名称格式时，i+XXX表示到XXX之后，i-XXX表示到XXX之前，i=XXX表示到XXX。<br>
"num2"的最终结果值必需大于"num1"，如参数列表的总数为5，num1设为-2，num2设为3，这样是非法的，因为-2的最终结果值为4，大于3。<br>
type模板的说明如下：
{{{
如果parameters的配置有name、sex，age这3个参数

query
各语句where语句部分的模板，例子如下：
动态语句生成的配置为：#auto[query,1,3]
生成的结果为：name = ? and sex = ? and age = ?

queryD
各语句where部分的动态参数模板，例子如下：
动态语句生成的配置为：#auto[queryD,1,2]
生成的结果为：#param(dAuto_1)[ and name = ?]#param(dAuto_2)[ and sex = ?]

update
update语句set部分的模板，例子如下：
动态语句生成的配置为：#auto[update,1,3]
生成的结果为：name = ?, sex = ?, age = ?

updateD
update语句set部分的动态参数模板，例子如下：
动态语句生成的配置为：#auto[updateD,1,2]
生成的结果为：#param(dAuto_1)[, name = ?]#param(dAuto_2)[, sex = ?]

insertN
insert语句列名部分的模板，例子如下：
动态语句生成的配置为：#auto[insertN,1,3]
生成的结果为：name, sex, age

insertND
insert语句列名部分的动态参数模板，例子如下：
动态语句生成的配置为：#auto[insertND,1,2]
生成的结果为：#param(dAuto_1)[, name]#param(dAuto_2)[, sex]

insertV
insert语句值部分的模板，例子如下：
#auto[insertV,1,3]
生成的结果为：?, ?, ?

insertVD
insert语句值部分的动态参数模板，例子如下：
#auto[insertVD,1,2]
生成的结果为：#param(dAuto_1)[, ?]#param(dAuto_2)[, ?]
}}}
名称格式的样例如下：
{{{
如果parameters的配置有name、sex，age这3个参数

动态语句生成的配置为：#auto[update,1,i-sex]
生成的结果为：name = ?

动态语句生成的配置为：#auto[update,1,i=sex]
生成的结果为：name = ?, sex = ?

动态语句生成的配置为：#auto[update,1,i+sex]
生成的结果为：name = ?, sex = ?, age = ?
}}}
<br>
=const 常量=
在语句中引用一个设置的常量。<br>
完整的常量写法如下：
{{{
#const(name)
}}}
以"#const"开始，后面"()"中的"name"为所引用的常量的名称。<br>
常量的用处在于简化语句，增加语句的可读性。尤其在语句中有较长的一段子查询的时候，将其定义成常量，在主语句中引用进来，这样主语句就不会显得很臃肿。<br>
常量的另一个用处就是兼容不同的数据库，如对"null"的判断，在oracle下为"nvl"，在mysql下为"ifnull"。这里我们就可以定义一个常量"null"，在语句中使用"#const(null)"，在项目中将常量"null"的值设为对应数据库的具体实现。<br>
<br>
=例子中的变量说明=
query为`self.micromagic.eterna.sql.QueryAdapter`的实例<br>
update为`self.micromagic.eterna.sql.UpdateAdapter`的实例<br>
factory为`self.micromagic.eterna.share.EternaFactory`的实例
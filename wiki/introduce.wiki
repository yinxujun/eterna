#summary 框架的设计理念
#labels Phase-Design

对于大部分小系统而言，需要处理的大部分工作其实就是CRUD操作。就是为了满足表单的填写、修改、查看、查询、删除等需求，因此需要一个框架能够快速地完成CRUD操作的编写。

然而，实际的业务场景中，CRUD中的每一个操作都不完全是一致的，需要填写和显示的内容、可修改的内容、查询结果中的内容这些可能都会有不同的需求，而且对于有些数据项的输入方式的要求可能也不在你提供的范围内。
基于以上这些情况，首先需要有一个完善的规则，才会有一个完善的框架。

说到规则，那就需要先分析一下CRUD操作中各个部分的需求。

首先，是数据的显示。最简单的情况就是需要显示的内容与数据模型完全一致，但是大部分情况却不是这样。比如：有些控制类的数据不需要显示，有些代码型的数据需要转换成显示值，有些数字或日期需要格式化，有些数据需要拆分成多个单元显示，有些数据需要合并成一个单元显示，有些数据需要有自己特殊的显示方式。
因此，关于数据的显示，需要分成两部分，一个是数据的读取部分，一个是数据的显示部分。
a. 读取部分定义需要哪些数据，处理代码的转换及格式化。
b. 显示部分定义展现及输入方式。

然后，是数据的添加或修改（删除也可以包含在这里，操作的数据就是删除的条件，如果是伪删除那就和修改一样了）。最简单的情况就是需要操作的数据与获得的参数完全一致，但大部分情况也不是这样。比如：参数的名称与数据的名称不一致，需要修改的数据为数据模型的子集或需要修改多个数据模型，有些参数需要进行类型转换，有些参数需要拆分后对应到多个数据，有些参数需要组合起来对应同一个数据。
因此，关于数据的添加或修改，需要分成三部分，数据的预处理、可操作的数据、参数与可操作数据的绑定关系。
c. 数据的预处理定义校验的规则，参数的合并及拆分或其他的加工方式。
d. 可操作的数据定义可以操作的数据的范围，相关的数据模型，数据类型转的换方式。
e. 数据的绑定定义参数与数据的对应关系，参数的来源（如：请求的参数、预处理的结果等）。

最后，是数据的查询。对于一个系统来说，查询比重一般是最大的。一般来说，查询中的条件和显示结果与数据模型也基本是不一致的，而且往往会涉及到多个数据模型。
因此，关于数据的查询，需要分成四部分，查询的条件、条件的显示、查询的结果、结果的显示。
f. 查询的条件定义哪些数据需要最为查询条件，条件的判断方式，条件的解析处理等。
g. 条件的显示定义查询条件的展现及输入方式。
h. 查询的结果定义需要查询出哪些数据，分别来自哪些数据模型，以及需要处理的代码转换及格式化。
i. 结果的显示定义结果列表的展现方式。

综合上面各部分，规则的第一步就是需要明确各部分的定义方式，使各个部分可以独立定义并且能满足所有的需求。
当然，以上这些部分都已有现成的规则了，如：
显示部分有JSP，HTML等
数据操作部分有hibernate等
预处理部分也有很多，如java的校验框架等

但是，对于大部分的CRUD操作来说，以上这些部分的独立却又带来了麻烦。同样的名称，同样的定义，需要在显示部分，数据部分，预处理部分等各个地方出现。这样的重复太多了，因此大部分的表单制作工具其实就是处理这些重复的事。但是仅仅靠自动代码生成来完成这些事并不能解决所有问题，比如各个部分之间有不一致的情况时，就需要对生成的代码进行调整。一旦出现了对目标代码的调整，接下来的工作就只能手动完成了，如果继续依靠工具，就会将你调整过的代码覆盖掉。
所以，规则的第二步就是需要建立各个部分的联系，这可以通过继承来实现。
显示部分（b, g, i）可以继承数据模型（a, f, h），预处理部分（c）、绑定部分（e）可以继承可操作的数据（d），可操作的数据（d）可以继承数据模型（a）等。
通过继承，就可以大大减少各个部分中出现的相同名称、相同定义的情况，从而达到定义一次多处使用的目的。

但是光有继承还不行，因为这样还无法处理有某几个数据单元的关系不一致的情况，如果又需要各个部分重新定义，那还是没有达到最理想的情况。
因此，规则的第三步，除了继承，还需要引入重载。
通过重载，就可以解决某几个数据单元不一致的情况。继承后，再通过重载来重新定义那些关系不一致的单元。
如：显示部分（b, g, i）继承了数据模型（a, f, h）之后，可以在显示部分重新定义有特殊需求的显示单元，其他单元仍然按照继承至数据模型的方式显示，这样就无需重写整个显示部分。


基于以上这三步整理出来的规则，不仅能处理所有CRUD相关的需求，并且能将重复的内容降至最低。
在此规则基础上构建的框架自然也就足够完善，能满足更多的情况。